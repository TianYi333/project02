/*
 * Copyright (C) 2018 - 2019 Xilinx, Inc.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification,
 * are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice,
 *    this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 * 3. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
 * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
 * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
 * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
 * OF SUCH DAMAGE.
 *
 */
#include "main.h"

extern volatile int dhcp_timoutcntr;
err_t dhcp_start(struct netif *netif);
static int complete_nw_thread;
struct netif server_netif;

uint8_t *recv_buffer = __recv_buffer_start;//雷达数据地址
uint8_t FLAG_MD5_check=0;

/******************************任务函数定义******************************/
static sys_thread_t main_thread_handle;
void main_thread(void *p);
void network_thread(void *p);
void md5_thread();

/******************************消息队列******************************/
QueueHandle_t Lwip_Server_Send_Queue =NULL;/* 以太网服务端数据发送队列 */
QueueHandle_t Lwip_Clientr1_Recv_Queue=NULL;/* 以太网客户端数据接收队列 */
QueueHandle_t Lwip_Clientr1_Send_Queue=NULL;/* 以太网客户端数据发送队列 */


static void print_ip(char *msg, ip_addr_t *ip)
{
	xil_printf(msg);
	xil_printf("%d.%d.%d.%d\n\r", ip4_addr1(ip), ip4_addr2(ip),
				ip4_addr3(ip), ip4_addr4(ip));
}

static void assign_default_ip(ip_addr_t *ip, ip_addr_t *mask, ip_addr_t *gw)
{
	int err;
	xil_printf("Configuring default IP %s \r\n", DEFAULT_IP_ADDRESS);

	err = inet_aton(DEFAULT_IP_ADDRESS, ip);
	if(!err)
		xil_printf("Invalid default IP address: %d\r\n", err);

	err = inet_aton(DEFAULT_IP_MASK, mask);
	if(!err)
		xil_printf("Invalid default IP MASK: %d\r\n", err);

	err = inet_aton(DEFAULT_GW_ADDRESS, gw);
	if(!err)
		xil_printf("Invalid default gateway address: %d\r\n", err);

	print_ip("Board IP:       ", ip);
	print_ip("Netmask :       ", mask);
	print_ip("Gateway :       ", gw);
}

void network_thread(void *p)
{
	u8_t mac_ethernet_address[] =	{ 0x00, 0x0a, 0x35, 0x00, 0x01, 0x02 };

	xil_printf("\n\r\n\r");
	xil_printf("------lwIP Socket Mode TCP Client Application------\r\n");

	/* Add network interface to the netif_list, and set it as default */
	if (!xemac_add(&server_netif, NULL, NULL, NULL, mac_ethernet_address,
						PLATFORM_EMAC_BASEADDR)) {
		xil_printf("Error adding N/W interface\r\n");
		return;
	}

	netif_set_default(&server_netif);

	/* specify that the network if is up */
	netif_set_up(&server_netif);

	/* start packet receive thread - required for lwIP operation */
	sys_thread_new("xemacif_input_thread",
			(void(*)(void*))xemacif_input_thread, &server_netif,
			THREAD_STACKSIZE,
			DEFAULT_THREAD_PRIO);

	complete_nw_thread = 1;

	/* Resume the main thread; auto-negotiation is completed */
	vTaskResume(main_thread_handle);

	vTaskDelete(NULL);

	return;
}

void main_thread(void *p)
{
	/* initialize lwIP before calling sys_thread_new */
	lwip_init();

	/* any thread using lwIP should be created using sys_thread_new */
	sys_thread_new("nw_thread", network_thread, NULL,
			THREAD_STACKSIZE,
			DEFAULT_THREAD_PRIO);

	/* Suspend Task until auto-negotiation is completed */
	if (!complete_nw_thread)
		vTaskSuspend(NULL);

	assign_default_ip(&(server_netif.ip_addr), &(server_netif.netmask),
							&(server_netif.gw));

	xil_printf("\r\n");
	/* start the application*/
	sys_thread_new("start_application_client1", start_application_client1, 0,
			512,
			DEFAULT_THREAD_PRIO);

	sys_thread_new("start_application_client2", start_application_client2, 0,
			512,
			DEFAULT_THREAD_PRIO);

//	sys_thread_new("start_application_server", start_application_server, 0,
//			512,
//			DEFAULT_THREAD_PRIO);

	vTaskDelete(NULL);
	return;
}

void clientr1_data_processing_thread()
{
	char clientr1_recv_buf[100];
	char* MD5_buf=(char*)malloc(50); // 动态分配内存;;
	char* clientr1_recv_data;
	char* serial_number;//序列号

	while(1)
	{
		if(xQueueReceive(Lwip_Clientr1_Recv_Queue,clientr1_recv_buf,100))
		{
			clientr1_recv_data = clientr1_recv_buf;
			serial_number = extract_after_marker_safe(clientr1_recv_data, "Bailu, FMCW_x,BL", ',');
			if (serial_number)
			{
				FLAG_MD5_check=1;
			    sprintf(MD5_buf, "%s!nmgfxt!@#$%%^&*", serial_number);// %和&可能被误认为格式说明符,因此双%%表示：输出一个实际的%字符
			    free(serial_number);
				xil_printf("send_buf: %s\n", MD5_buf);
				char* result=md5_APP(MD5_buf);
//				free(MD5_buf);
				 if (result)
				 {
					 printf("MD5 Hash Result: %s\n", result);
					 xQueueSendFromISR(Lwip_Clientr1_Send_Queue,result,0);
				     free(result);// 使用完后，必须调用 free 释放内存！
				 }
				 else
				 {
					 printf("Memory allocation failed!\n");
				 }
			}
		}
	}
}

int main()
{
	main_thread_handle = sys_thread_new("main_thread", main_thread, 0,
			THREAD_STACKSIZE,
			DEFAULT_THREAD_PRIO);

	sys_thread_new("clientr1_data_processing_thread", clientr1_data_processing_thread, 0,
			512,
			DEFAULT_THREAD_PRIO);

	Lwip_Server_Send_Queue = xQueueCreate(2,2048);//网口发送数据暂订为32字节
	Lwip_Clientr1_Recv_Queue = xQueueCreate(2,100);//网口发送数据暂订为50字节
	Lwip_Clientr1_Send_Queue = xQueueCreate(2,100);//网口发送数据暂订为50字节

	vTaskStartScheduler();
	while(1);
	return 0;
}
