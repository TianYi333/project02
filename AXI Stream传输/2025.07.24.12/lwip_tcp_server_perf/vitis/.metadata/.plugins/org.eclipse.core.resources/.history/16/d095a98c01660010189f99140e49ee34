#include "AXI_DMA.h"

static XAxiDma axidma;     //XAxiDma实例
static u8 *rx_buffer_ptr;    // 接收缓冲区指针
volatile int tx_done;      //发送完成标志
volatile int rx_done;      //接收完成标志
volatile int error;        //传输出错标志

int AXI_DMA_APP(void)
{
    int status;
    rx_buffer_ptr = (u8 *) RX_BUFFER_BASE;

    xil_printf("\r\n--- Entering main() --- \r\n");

    // 初始化DMA设备
    if (InitDma(&axidma, DMA_DEV_ID) != XST_SUCCESS) {
        xil_printf("DMA初始化失败！\r\n");
        return XST_FAILURE;
    }

    // 设置中断系统
    if (SetupInterruptSystem(&xInterruptController, &axidma, RX_INTR_ID) != XST_SUCCESS) {
        xil_printf("中断系统设置失败！\r\n");
        return XST_FAILURE;
    }

    //初始化标志信号
    rx_done = 0;
    error   = 0;

    // 初始化启动第一次DMA传输
    //发送或者读取数据（传输数据的方向，XAXIDMA_DMA_TO_DEVICE和XAXIDMA_DEVICE_TO_DMA）
	status = XAxiDma_SimpleTransfer(&axidma, (UINTPTR) rx_buffer_ptr,
									MAX_PKT_LEN, XAXIDMA_DEVICE_TO_DMA);
    if (status != XST_SUCCESS) {
        xil_printf("首次启动DMA传输失败！\r\n");
    }
    else {
        xil_printf("DMA传输已启动...\r\n");
    }

    while (1)
    {
		vTaskDelay(10);
		if(rx_done)
		{
			Xil_DCacheFlushRange((UINTPTR) rx_buffer_ptr, MAX_PKT_LEN);   //刷新Data Cache
			// 处理接收到的数据
			ProcessReceivedData(rx_buffer_ptr, MAX_PKT_LEN);

			// 重新启动DMA传输
			status = XAxiDma_SimpleTransfer(&axidma, (UINTPTR) rx_buffer_ptr,
											MAX_PKT_LEN, XAXIDMA_DEVICE_TO_DMA);
			if (status != XST_SUCCESS) {
				xil_printf("重启DMA传输失败！\r\n");
			}

			xil_printf("Successfully ran AXI DMA Loop\r\n");
			rx_done = 0;
			error   = 0;
		}
    }
	return XST_SUCCESS;
}

//初始化AXI DMA设备
int InitDma(XAxiDma *AxiDmaPtr, u16 DeviceId)
{
    int status;
    XAxiDma_Config *config;

    config = XAxiDma_LookupConfig(DeviceId);
    if (!config) {
    	xil_printf("无法找到DMA设备配置！\r\n");
        return XST_FAILURE;
    }
    // 强制配置为非SG模式（关键修改）
    config->HasSg = 0;

    //初始化DMA引擎
    status = XAxiDma_CfgInitialize(AxiDmaPtr, config);
    if (status != XST_SUCCESS) {
    	xil_printf("无法初始化DMA设备！\r\n");
        return XST_FAILURE;
    }

//    if (XAxiDma_HasSg(AxiDmaPtr)) {
//    	 xil_printf("DMA设备配置为SG模式，但示例使用非SG模式！\r\n");
//        return XST_FAILURE;
//    }

    // 禁用所有中断（将在中断处理函数中启用）
    XAxiDma_IntrDisable(AxiDmaPtr, XAXIDMA_IRQ_ALL_MASK, XAXIDMA_DEVICE_TO_DMA);
    // 在初始化后添加
    xil_printf("DMA配置验证：HasSG=%d\r\n", XAxiDma_HasSg(AxiDmaPtr));

    // 读取实际的中断状态寄存器值（用于调试）
    u32 irq_status = XAxiDma_IntrGetIrq(AxiDmaPtr, XAXIDMA_DEVICE_TO_DMA);
    xil_printf("初始化后的中断状态：0x%08X\r\n", irq_status);
    return XST_SUCCESS;
}

//建立DMA中断系统
//  @param   int_ins_ptr是指向XScuGic实例的指针
//  @param   AxiDmaPtr是指向DMA引擎实例的指针
//  @param   rx_intr_id是RX通道中断ID
//  @return：成功返回XST_SUCCESS，否则返回XST_FAILURE
int SetupInterruptSystem(XScuGic * int_ins_ptr, XAxiDma * axidma_ptr, u16 rx_intr_id)
{
    int status;
//    XScuGic_Config *intc_config;

//    //初始化中断控制器驱动
//    intc_config = XScuGic_LookupConfig(INTC_DEVICE_ID);
//    if (NULL == intc_config) {
//        return XST_FAILURE;
//    }
//    status = XScuGic_CfgInitialize(int_ins_ptr, intc_config,
//            intc_config->CpuBaseAddress);
//    if (status != XST_SUCCESS) {
//        return XST_FAILURE;
//    }

    //设置优先级和触发类型
    XScuGic_SetPriorityTriggerType(int_ins_ptr, rx_intr_id, 0xA0, 0x3);

    //为中断设置中断处理函数
    status = XScuGic_Connect(int_ins_ptr, rx_intr_id,
            (Xil_InterruptHandler) rx_intr_handler, axidma_ptr);
    if (status != XST_SUCCESS) {
        return status;
    }
    // 使能中断
    XScuGic_Enable(int_ins_ptr, rx_intr_id);

//    //启用来自硬件的中断
//    Xil_ExceptionInit();
//    Xil_ExceptionRegisterHandler(XIL_EXCEPTION_ID_INT,
//            (Xil_ExceptionHandler) XScuGic_InterruptHandler,
//            (void *) int_ins_ptr);
//    Xil_ExceptionEnable();

    //使能DMA中断
    XAxiDma_IntrEnable(&axidma, XAXIDMA_IRQ_ALL_MASK, XAXIDMA_DMA_TO_DEVICE);
    XAxiDma_IntrEnable(&axidma, XAXIDMA_IRQ_ALL_MASK, XAXIDMA_DEVICE_TO_DMA);

    return XST_SUCCESS;
}

//DMA RX中断处理函数
void rx_intr_handler(void *callback)
{
    u32 irq_status;
    int timeout;
    XAxiDma *axidma_inst = (XAxiDma *) callback;

    //读取中断状态
    irq_status = XAxiDma_IntrGetIrq(axidma_inst, XAXIDMA_DEVICE_TO_DMA);//函数读取DMASR状态寄存器中的中断位来判断发送了哪种中断
    //清除已确认的中断
    XAxiDma_IntrAckIrq(axidma_inst, irq_status, XAXIDMA_DEVICE_TO_DMA);//函数确认待处理的中断（通过向中断位写1，可以清除发生的中断）

    // 检查是否有错误中断
    if ((irq_status & XAXIDMA_IRQ_ERROR_MASK)) {//如果发现是接收出现错误的中断，则使用 XAxiDma_Reset 函数复位 DMA，并使用 XAxiDma_ResetIsDone 函数判断是否复位完成。
    	xil_printf("中断状态：0x%08X\r\n", irq_status);
        error = 1;
        XAxiDma_Reset(axidma_inst);
        timeout = RESET_TIMEOUT_COUNTER;
        while (timeout) {
            if (XAxiDma_ResetIsDone(axidma_inst))
                break;
            timeout -= 1;
        }
        return;
    }

    //Rx完成
    if ((irq_status & XAXIDMA_IRQ_IOC_MASK))
        rx_done = 1;
}

//此函数禁用DMA引擎的中断
void disable_intr_system(XScuGic * int_ins_ptr, u16 tx_intr_id,	u16 rx_intr_id)
{
    XScuGic_Disconnect(int_ins_ptr, tx_intr_id);
    XScuGic_Disconnect(int_ins_ptr, rx_intr_id);
}

//检查数据缓冲区
void ProcessReceivedData(u8 *Buffer, int length)
{
    u8 *rx_packet;
    int i = 0;
    rx_packet = (u8 *) Buffer;
    for (i = 0; i < length; i++) {
        xil_printf("Data : %x\r\n", rx_packet[i]);
    }
}

