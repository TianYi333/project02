

#include "emmc_rw.h"

#define FILE_NAME "ZDYZ.txt"                //定义文件名
const char src_str[30] = "www.openedv.com"; //定义文本内容
static FATFS fatfs;                         //文件系统

//初始化文件系统
int platform_init_fs()
{
	FRESULT status;
	TCHAR *Path = "0:/";
	BYTE work[FF_MAX_SS];

    //注册一个工作区(挂载分区文件系统)
    //在使用任何其它文件函数之前，必须使用f_mount函数为每个使用卷注册一个工作区
	status = f_mount(&fatfs, Path, 1);  //挂载SD卡
	if (status != FR_OK) {
		xil_printf("Volume is not FAT formated; formating FAT\r\n");
		//格式化SD卡
		status = f_mkfs(Path, FM_FAT32, 0, work, sizeof work);
		if (status != FR_OK) {
			xil_printf("Unable to format FATfs\r\n");
			return -1;
		}
		//格式化之后，重新挂载SD卡
		status = f_mount(&fatfs, Path, 1);
		if (status != FR_OK) {
			xil_printf("Unable to mount FATfs\r\n");
			return -1;
		}
	}
	return 0;
}

//挂载SD(TF)卡
int sd_mount()
{
    FRESULT status;
    //初始化文件系统（挂载SD卡，如果挂载不成功，则格式化SD卡）
    status = platform_init_fs();
    if(status){
        xil_printf("ERROR: f_mount returned %d!\n",status);
        return XST_FAILURE;
    }
    return XST_SUCCESS;
}

//SD卡写数据
int sd_write_data(char *file_name,u32 src_addr,u32 byte_len)
{
    FIL fil;         //文件对象
    UINT bw;         //f_write函数返回已写入的字节数

    //打开一个文件,如果不存在，则创建一个文件
    f_open(&fil,file_name,FA_CREATE_ALWAYS | FA_WRITE);
    //移动打开的文件对象的文件读/写指针     0:指向文件开头
    f_lseek(&fil, 0);
    //向文件中写入数据
    f_write(&fil,(void*) src_addr,byte_len,&bw);
    //关闭文件
    f_close(&fil);
    return 0;
}

//SD卡读数据
int sd_read_data(char *file_name,u32 src_addr,u32 byte_len)
{
	FIL fil;         //文件对象
    UINT br;         //f_read函数返回已读出的字节数

    //打开一个只读的文件
    f_open(&fil,file_name,FA_READ);
    //移动打开的文件对象的文件读/写指针     0:指向文件开头
    f_lseek(&fil,0);
    //从SD卡中读出数据
    f_read(&fil,(void*)src_addr,byte_len,&br);
    //关闭文件
    f_close(&fil);
    return 0;
}

//main函数
int emmc_rw()
{
    int status,len;
    char dest_str[30] = "";

    status = sd_mount();           //挂载SD卡
    if(status != XST_SUCCESS){
		xil_printf("Failed to open SD card!\n");
		return 0;
    }
    else
        xil_printf("Success to open SD card!\n");

    len = strlen(src_str);         //计算字符串长度
    //SD卡写数据
    sd_write_data(FILE_NAME,(u32)src_str,len);
    //SD卡读数据
    sd_read_data(FILE_NAME,(u32)dest_str,len);

    //比较写入的字符串和读出的字符串是否相等
    if (strcmp(src_str, dest_str) == 0)
    	xil_printf("src_str is equal to dest_str,SD card test success!\n");
    else
    	xil_printf("src_str is not equal to dest_str,SD card test failed!\n");

    return 0;
  }








#include "xqspips.h"
#include "xparameters.h"

#define QSPI_DEVICE_ID      XPAR_XQSPIPS_0_DEVICE_ID
#define FLASH_SECTOR_SIZE   4096   // Micron N25Q128扇区大小
#define SAVE_ADDRESS        0x100000  // 数据存储起始地址（示例）

// QSPI实例
static XQspiPs QspiInstance;

int QSPI_Init() {
    XQspiPs_Config *Config;
    int Status;

    // 查找并初始化QSPI控制器
    Config = XQspiPs_LookupConfig(QSPI_DEVICE_ID);
    if (Config == NULL) return XST_FAILURE;

    Status = XQspiPs_CfgInitialize(&QspiInstance, Config, Config->BaseAddress);
    if (Status != XST_SUCCESS) return XST_FAILURE;

    // 设置QSPI模式为Quad SPI（4线模式）
    XQspiPs_SetOptions(&QspiInstance, XQSPIPS_FORCE_SSELECT_OPTION | XQSPIPS_QSPI_MODE_OPTION);
    XQspiPs_SetClkPrescaler(&QspiInstance, XQSPIPS_CLK_PRESCALE_8);  // 50MHz / 8 = 6.25MHz

    return XST_SUCCESS;
}

// 擦除指定地址的扇区
int QSPI_EraseSector(u32 Address) {
    u8 WriteEnableCmd = 0x06;    // WREN命令
    u8 EraseCmd[4] = {0x20,      // Sector Erase (4-byte地址模式)
                     (Address >> 24) & 0xFF,
                     (Address >> 16) & 0xFF,
                     (Address >> 8) & 0xFF};

    XQspiPs_PolledTransfer(&QspiInstance, &WriteEnableCmd, NULL, 1);  // 使能写操作
    return XQspiPs_PolledTransfer(&QspiInstance, EraseCmd, NULL, 4);  // 发送擦除命令
}

// 写入数据到指定地址
int QSPI_WriteData(u32 Address, u8 *Data, u32 Length) {
    u8 WriteEnableCmd = 0x06;
    u8 PageWriteCmd[4] = {0x32,  // Quad Page Program (4-byte地址模式)
                         (Address >> 24) & 0xFF,
                         (Address >> 16) & 0xFF,
                         (Address >> 8) & 0xFF};

    XQspiPs_PolledTransfer(&QspiInstance, &WriteEnableCmd, NULL, 1);
    XQspiPs_PolledTransfer(&QspiInstance, PageWriteCmd, Data, Length + 4);  // 命令+数据
    return XST_SUCCESS;
}

// 从指定地址读取数据
int QSPI_ReadData(u32 Address, u8 *Buffer, u32 Length) {
    u8 ReadCmd[5] = {0x6B,  // Quad I/O Read (4-byte地址 + dummy cycle)
                    (Address >> 24) & 0xFF,
                    (Address >> 16) & 0xFF,
                    (Address >> 8) & 0xFF,
                    0xFF};  // Dummy字节

    return XQspiPs_PolledTransfer(&QspiInstance, ReadCmd, Buffer, Length + 5);
}
